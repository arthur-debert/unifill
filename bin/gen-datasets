#!/usr/bin/env zsh
#
# gen-datasets - Unicode dataset generator for the unifill plugin
#
# This script generates Unicode datasets in various formats (lua, csv, txt) for use
# with the unifill plugin. By default, it only generates files that don't already
# exist in the data directory, making it efficient for incremental updates.
#
# When the --force flag is used, it removes all existing files and regenerates them,
# which is useful for ensuring all data is up-to-date or when the dataset structure
# has changed.
#
# The generated files are placed in the project's data directory and also copied to
# the XDG_DATA_HOME directory for system-wide access.

# Exit immediately if a command exits with a non-zero status.
set -e

# Get the absolute path of the directory where the script is located
SCRIPT_DIR="${0:a:h}"

# Project root is assumed to be one level up from the 'bin' directory
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

# Define key directories and filenames
GLYPH_CATCHER_DIR="$PROJECT_ROOT/glyph-catcher"

# Use XDG_DATA_HOME if available, otherwise use default location
if [ -n "$XDG_DATA_HOME" ]; then
  XDG_DATA_DIR="$XDG_DATA_HOME/unifill"
else
  XDG_DATA_DIR="$HOME/.local/share/unifill"
fi

# Default destination is the project data directory
# But we'll also copy to XDG_DATA_HOME for system-wide access
DESTINATION_DIR="$PROJECT_ROOT/data"

# Define file formats and their corresponding filenames
declare -A FORMAT_FILES
FORMAT_FILES[lua]="unicode_data.lua"
FORMAT_FILES[csv]="unicode_data.csv"
FORMAT_FILES[txt]="unicode_data.txt"

# Default formats to generate
FORMATS=("lua" "txt" "csv")
# Additional arguments to pass to glyph-catcher
EXTRA_ARGS=""
# Force flag to regenerate all files
FORCE=false

# Parse command line arguments
# Parse command line arguments
while [[ $# -gt 0 ]]; do
  case $1 in
  --format)
    if [[ "$2" == "all" ]]; then
      FORMATS=("lua" "csv" "txt")
    else
      FORMATS=("$2")
    fi
    shift 2
    ;;
  --force)
    FORCE=true
    shift
    ;;
  --help|-h)
    cat << EOF
Usage: $(basename $0) [OPTIONS] [-- EXTRA_ARGS]

Generate Unicode datasets for the unifill plugin.

OPTIONS:
  --format FORMAT   Specify which format(s) to generate
                    FORMAT can be: lua, csv, txt, or all
                    Default: lua, txt, csv

  --force          Remove all existing files and regenerate them
                   Without this flag, only missing files are generated

  --help, -h       Display this help message and exit

  -- EXTRA_ARGS    Additional arguments passed directly to glyph-catcher
                   e.g., --unicode-blocks "Basic Latin"

BEHAVIOR:
  By default, this script only generates files that don't already exist in the
  data directory. This makes it efficient for incremental updates.

  When --force is used, all existing files are removed before generating new ones.
  This ensures all data is up-to-date and is useful when the dataset structure
  has changed.

  Generated files are placed in:
  - Project data directory: $PROJECT_ROOT/data/
  - System-wide directory: \$XDG_DATA_HOME/unifill/ or ~/.local/share/unifill/

EXAMPLES:
  # Generate only missing files
  $(basename $0)

  # Force regeneration of all files
  $(basename $0) --force

  # Generate only the Lua format
  $(basename $0) --format lua

  # Generate only specific Unicode blocks
  $(basename $0) -- --unicode-blocks "Basic Latin,Latin-1 Supplement"
EOF
    exit 0
    ;;
  --)
    # Everything after -- is passed to glyph-catcher
    shift
    # Store all remaining arguments in an array to preserve spaces
    EXTRA_ARGS=("$@")
    break
    ;;
  *)
    echo "Unknown option: $1"
    echo "Run '$(basename $0) --help' for usage information."
    exit 1
    ;;
  esac
done
# Ensure the destination directories exist
mkdir -p "$DESTINATION_DIR"
mkdir -p "$XDG_DATA_DIR"

# If force flag is set, remove all existing files
if [ "$FORCE" = true ]; then
  echo "Force flag set. Removing all existing files in $DESTINATION_DIR..."
  rm -f "$DESTINATION_DIR"/*.*
  echo "All files removed."
fi

# Function to check if a file needs to be generated
needs_generation() {
  local format=$1
  local file_path="$DESTINATION_DIR/${FORMAT_FILES[$format]}"
  
  if [ ! -f "$file_path" ]; then
    return 0  # File doesn't exist, needs generation
  elif [ "$FORCE" = true ]; then
    return 0  # Force flag is set, regenerate regardless
  else
    return 1  # File exists and no force flag, skip generation
  fi
}

echo "Unicode dataset generator for unifill"
echo "------------------------------------"
echo "Formats to process: ${FORMATS[*]}"
echo "Force regeneration: $([ "$FORCE" = true ] && echo "Yes" || echo "No (only generating missing files)")"
echo ""

# Navigate to the glyph-catcher directory
cd "$GLYPH_CATCHER_DIR"

# Install dependencies using Poetry
echo "Installing/updating dependencies with Poetry..."
poetry install --no-interaction --no-ansi >/dev/null 2>&1

# Track if any files were generated
FILES_GENERATED=false

# Generate each requested format
for format in "${FORMATS[@]}"; do
  # Get the filename for this format
  GENERATED_FILE_NAME="${FORMAT_FILES[$format]}"
  SOURCE_FILE_IN_DATAFETCH_DIR="$GENERATED_FILE_NAME"
  DESTINATION_FILE_PATH="$DESTINATION_DIR/$GENERATED_FILE_NAME"
  
  # Check if we need to generate this format
  if needs_generation "$format"; then
    echo "Generating $format format..."
    FILES_GENERATED=true
    
    # Run the data fetching script using Poetry with the specified format
    if [[ ${#EXTRA_ARGS[@]} -gt 0 ]]; then
      echo "Using additional arguments: ${EXTRA_ARGS[*]}"
      poetry run glyph-catcher generate --format "$format" "${EXTRA_ARGS[@]}"
    else
      poetry run glyph-catcher generate --format "$format"
    fi

    # Check if the file was generated
    if [ ! -f "$SOURCE_FILE_IN_DATAFETCH_DIR" ]; then
      echo "Error: $SOURCE_FILE_IN_DATAFETCH_DIR not found in $PWD after running the script."
      exit 1
    fi

    # Move the generated file to the project's data directory
    mv "$SOURCE_FILE_IN_DATAFETCH_DIR" "$DESTINATION_FILE_PATH"
    
    # Copy to XDG data directory for system-wide access
    XDG_FILE_PATH="$XDG_DATA_DIR/$GENERATED_FILE_NAME"
    cp "$DESTINATION_FILE_PATH" "$XDG_FILE_PATH"

    printf "Generated: \e[32m%s\e[0m\n" "$DESTINATION_FILE_PATH"
    printf "Copied to: \e[32m%s\e[0m\n" "$XDG_FILE_PATH"
  else
    printf "Skipping \e[33m%s\e[0m format: File already exists\n" "$format"
  fi
done
# Navigate back to the project root
cd "$PROJECT_ROOT"

echo ""
echo ""
echo "------------------------------------"
echo "SUMMARY"
echo "------------------------------------"
if [ "$FILES_GENERATED" = true ]; then
  echo "✓ Dataset generation completed successfully"
  
  # Count generated and skipped formats
  GENERATED_COUNT=0
  SKIPPED_COUNT=0
  for format in "${FORMATS[@]}"; do
    if needs_generation "$format"; then
      GENERATED_COUNT=$((GENERATED_COUNT + 1))
    else
      SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
    fi
  done
  
  echo "  Generated: $GENERATED_COUNT format(s)"
  echo "  Skipped:   $SKIPPED_COUNT format(s)"
  echo ""
  echo "Files are available in:"
  echo "  - Project directory: $DESTINATION_DIR/"
  echo "  - System directory:  $XDG_DATA_DIR/"
  echo ""
  echo "These files are used by the unifill plugin for Unicode character lookup."
else
  echo "✓ No files needed to be generated"
  echo "  All requested formats already exist in $DESTINATION_DIR/"
  echo ""
  echo "To regenerate all files (useful after dataset structure changes):"
  echo "  $0 --force"
fi
