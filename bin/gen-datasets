#!/usr/bin/env zsh

# Exit immediately if a command exits with a non-zero status.
set -e

# Get the absolute path of the directory where the script is located
SCRIPT_DIR="${0:a:h}"

# Project root is assumed to be one level up from the 'bin' directory
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

# Define key directories and filenames
GLYPH_CATCHER_DIR="$PROJECT_ROOT/glyph-catcher"

# Use XDG_DATA_HOME if available, otherwise use default location
if [ -n "$XDG_DATA_HOME" ]; then
  XDG_DATA_DIR="$XDG_DATA_HOME/unifill"
else
  XDG_DATA_DIR="$HOME/.local/share/unifill"
fi

# Default destination is the project data directory
# But we'll also copy to XDG_DATA_HOME for system-wide access
DESTINATION_DIR="$PROJECT_ROOT/data"

# Define file formats and their corresponding filenames
declare -A FORMAT_FILES
FORMAT_FILES[lua]="unicode_data.lua"
FORMAT_FILES[csv]="unicode_data.csv"
FORMAT_FILES[txt]="unicode_data.txt"

# Default formats to generate
FORMATS=("lua" "txt" "csv")
# Additional arguments to pass to glyph-catcher
EXTRA_ARGS=""

# Parse command line arguments
while [[ $# -gt 0 ]]; do
  case $1 in
  --format)
    if [[ "$2" == "all" ]]; then
      FORMATS=("lua" "csv" "txt")
    else
      FORMATS=("$2")
    fi
    shift 2
    ;;
  --)
    # Everything after -- is passed to glyph-catcher
    shift
    # Store all remaining arguments in an array to preserve spaces
    EXTRA_ARGS=("$@")
    break
    ;;
  *)
    echo "Unknown option: $1"
    echo "Usage: $0 [--format FORMAT] [-- EXTRA_ARGS]"
    echo "FORMAT can be: lua, csv, txt, or all"
    echo "EXTRA_ARGS are passed directly to glyph-catcher (e.g., --unicode-blocks \"Basic Latin\")"
    exit 1
    ;;
  esac
done

# Ensure the destination directories exist
mkdir -p "$DESTINATION_DIR"
mkdir -p "$XDG_DATA_DIR"

# Navigate to the glyph-catcher directory
cd "$GLYPH_CATCHER_DIR"

# Install dependencies using Poetry
echo "Installing/updating dependencies with Poetry..."
poetry install --no-interaction --no-ansi >/dev/null 2>&1

# Generate each requested format
for format in "${FORMATS[@]}"; do
  echo "Generating $format format..."

  # Get the filename for this format
  GENERATED_FILE_NAME="${FORMAT_FILES[$format]}"
  SOURCE_FILE_IN_DATAFETCH_DIR="$GENERATED_FILE_NAME"
  DESTINATION_FILE_PATH="$DESTINATION_DIR/$GENERATED_FILE_NAME"

  # Run the data fetching script using Poetry with the specified format
  if [[ ${#EXTRA_ARGS[@]} -gt 0 ]]; then
    echo "Using additional arguments: ${EXTRA_ARGS[*]}"
    poetry run glyph-catcher generate --format "$format" "${EXTRA_ARGS[@]}"
  else
    poetry run glyph-catcher generate --format "$format"
  fi

  # Check if the file was generated
  if [ ! -f "$SOURCE_FILE_IN_DATAFETCH_DIR" ]; then
    echo "Error: $SOURCE_FILE_IN_DATAFETCH_DIR not found in $PWD after running the script."
    exit 1
  fi

  # Move the generated file to the project's data directory
  mv "$SOURCE_FILE_IN_DATAFETCH_DIR" "$DESTINATION_FILE_PATH"
  
  # Copy to XDG data directory for system-wide access
  XDG_FILE_PATH="$XDG_DATA_DIR/$GENERATED_FILE_NAME"
  cp "$DESTINATION_FILE_PATH" "$XDG_FILE_PATH"

  printf "Generated: \e[32m%s\e[0m\n" "$DESTINATION_FILE_PATH"
  printf "Copied to: \e[32m%s\e[0m\n" "$XDG_FILE_PATH"
done

# Navigate back to the project root
cd "$PROJECT_ROOT"

echo "All requested formats have been generated successfully."
