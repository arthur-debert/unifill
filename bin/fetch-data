#!/usr/bin/env zsh

# Exit immediately if a command exits with a non-zero status.
set -e

# Get the absolute path of the directory where the script is located
SCRIPT_DIR="${0:a:h}"

# Project root is assumed to be one level up from the 'bin' directory
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

# Define key directories and filenames
GLYPH_CATCHER_DIR="$PROJECT_ROOT/unifill-datafetch"  # Directory name will be changed later
DESTINATION_PARENT_DIR="$PROJECT_ROOT/data"
DESTINATION_SUBDIR_NAME="unifill-datafetch"  # Keep this for backward compatibility
FULL_DESTINATION_DIR="$DESTINATION_PARENT_DIR/$DESTINATION_SUBDIR_NAME"

# Define file formats and their corresponding filenames
declare -A FORMAT_FILES
FORMAT_FILES[lua]="unicode_data.lua"
FORMAT_FILES[csv]="unicode_data.csv"
FORMAT_FILES[txt]="unicode_data.txt"

# Default formats to generate
FORMATS=("lua" "txt")
# Additional arguments to pass to glyph-catcher
EXTRA_ARGS=""

# Parse command line arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --format)
      if [[ "$2" == "all" ]]; then
        FORMATS=("lua" "csv" "txt")
      else
        FORMATS=("$2")
      fi
      shift 2
      ;;
    --)
      # Everything after -- is passed to glyph-catcher
      shift
      # Store all remaining arguments in an array to preserve spaces
      EXTRA_ARGS=("$@")
      break
      ;;
    *)
      echo "Unknown option: $1"
      echo "Usage: $0 [--format FORMAT] [-- EXTRA_ARGS]"
      echo "FORMAT can be: lua, csv, txt, or all"
      echo "EXTRA_ARGS are passed directly to glyph-catcher (e.g., --unicode-blocks \"Basic Latin\")"
      exit 1
      ;;
  esac
done

# Ensure the destination directory exists
mkdir -p "$FULL_DESTINATION_DIR"

# Navigate to the glyph-catcher directory
cd "$GLYPH_CATCHER_DIR"

# Install dependencies using Poetry
echo "Installing/updating dependencies with Poetry..."
poetry install --no-interaction --no-ansi >/dev/null 2>&1

# Generate each requested format
for format in "${FORMATS[@]}"; do
  echo "Generating $format format..."
  
  # Get the filename for this format
  GENERATED_FILE_NAME="${FORMAT_FILES[$format]}"
  SOURCE_FILE_IN_DATAFETCH_DIR="$GENERATED_FILE_NAME"
  DESTINATION_FILE_PATH="$FULL_DESTINATION_DIR/$GENERATED_FILE_NAME"
  
  # Run the data fetching script using Poetry with the specified format
  if [[ ${#EXTRA_ARGS[@]} -gt 0 ]]; then
    echo "Using additional arguments: ${EXTRA_ARGS[*]}"
    poetry run glyph-catcher generate --format "$format" "${EXTRA_ARGS[@]}"
  else
    poetry run glyph-catcher generate --format "$format"
  fi
  
  # Check if the file was generated
  if [ ! -f "$SOURCE_FILE_IN_DATAFETCH_DIR" ]; then
    echo "Error: $SOURCE_FILE_IN_DATAFETCH_DIR not found in $PWD after running the script."
    exit 1
  fi
  
  # Move the generated file to the project's data/unifill-datafetch/ directory
  mv "$SOURCE_FILE_IN_DATAFETCH_DIR" "$DESTINATION_FILE_PATH"
  
  printf "Generated: \e[32m%s\e[0m\n" "$DESTINATION_FILE_PATH"
done

# Navigate back to the project root
cd "$PROJECT_ROOT"

echo "All requested formats have been generated successfully."
